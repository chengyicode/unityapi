<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <link href="./css/stylesheet.css" rel="stylesheet" type="text/css"><title>Unity - Scripting API: SurfaceObserver</title></head> <body> <div class="content"><div class="section"><div class="mb20 clear" id=""><h1 class="heading inherit">SurfaceObserver</h1><div class="clear"></div><p class="cl mb0 left mr10">class in
          UnityEngine.XR.WSA</p><p class="cl mb0 left mr10">/</p><p class="cl mb0 left">Implemented in:<a href="UnityEngine.VRModule.html" class="cl">UnityEngine.VRModule</a></p><div class="clear"></div><div class="suggest"><div class="suggest-wrap rel hide"><div class="loading hide"><div></div><div></div><div></div></div></div></div><a href="" class="switch-link gray-btn sbtn left hide"></a><div class="clear"></div></div><div class="subsection"><div class="signature"><div class="signature-CS sig-block"><span style="color:red;"></span></div></div></div><div class="subsection"><h2>Description   描述</h2><p>SurfaceObserver is the main API portal for spatial mapping functionality in Unity.</p></div><div class="subsection"><p>Users should create an SurfaceObserver, call Update to generate SurfaceChanged events, call GetMeshAsync for those surfaces that are interesting, and call Dispose when finished with the object.</p></div><div class="subsection"><h2>Constructors</h2><table class="list">
      <tr><td class="descn"></td><td class="lbl"><a href="XR.WSA.SurfaceObserver-ctor.html">SurfaceObserver</a></td><td class="desc"></td><td class="desc1">Basic constructor for SurfaceObserver.</td></tr>
    </table></div><div class="subsection"><h2>Public Methods   公共方法</h2><table class="list">
      <tr><td class="descn"></td><td class="lbl"><a href="XR.WSA.SurfaceObserver.Dispose.html">Dispose</a></td><td class="desc"></td><td class="desc1">Call Dispose when the SurfaceObserver is no longer needed.  This will ensure that the object is cleaned up appropriately but will not affect any Meshes, components, or objects returned by RequestMeshAsync.</td></tr>
      <tr><td class="descn"></td><td class="lbl"><a href="XR.WSA.SurfaceObserver.RequestMeshAsync.html">RequestMeshAsync</a></td><td class="desc"></td><td class="desc1">Call RequestMeshAsync to start the process of baking mesh data for the specified surface.  This data may take several frames to create.  Baked data will be delivered through the specified SurfaceDataReadyDelegate.  This method will throw ArgumentNullExcpetion and ArgumentException if parameters specified in the dataRequest are invalid.</td></tr>
      <tr><td class="descn"></td><td class="lbl"><a href="XR.WSA.SurfaceObserver.SetVolumeAsAxisAlignedBox.html">SetVolumeAsAxisAlignedBox</a></td><td class="desc"></td><td class="desc1">This method sets the observation volume as an axis aligned box at the requested location.  Successive calls can be used to reshape the observation volume and/or to move it in the Scene as needed.  Extents are the distance from the center of the box to its edges along each axis.</td></tr>
      <tr><td class="descn"></td><td class="lbl"><a href="XR.WSA.SurfaceObserver.SetVolumeAsFrustum.html">SetVolumeAsFrustum</a></td><td class="desc"></td><td class="desc1">This method sets the observation volume as a frustum at the requested location.  Successive calls can be used to reshape the observation volume and/or to move it in the Scene as needed.</td></tr>
      <tr><td class="descn"></td><td class="lbl"><a href="XR.WSA.SurfaceObserver.SetVolumeAsOrientedBox.html">SetVolumeAsOrientedBox</a></td><td class="desc"></td><td class="desc1">This method sets the observation volume as an oriented box at the requested location.  Successive calls can be used to reshape the observation volume and/or to move it in the Scene as needed.  Extents are the distance from the center of the box to its edges along each axis.</td></tr>
      <tr><td class="descn"></td><td class="lbl"><a href="XR.WSA.SurfaceObserver.SetVolumeAsSphere.html">SetVolumeAsSphere</a></td><td class="desc"></td><td class="desc1">This method sets the observation volume as a sphere at the requested location.  Successive calls can be used to reshape the observation volume and/or to move it in the Scene as needed.</td></tr>
      <tr><td class="descn"></td><td class="lbl"><a href="XR.WSA.SurfaceObserver.Update.html">Update</a></td><td class="desc"></td><td class="desc1">Update generates SurfaceChanged events which are propagated through the specified callback.  If no callback is specified, the system will throw an ArgumentNullException.  Generated callbacks are synchronous with this call.  Scenes containing multiple SurfaceObservers should consider using different callbacks so that events can be properly routed.</td></tr>
    </table></div><div class="subsection"><h2>Delegates</h2><table class="list">
      <tr><td class="descn"></td><td class="lbl"><a href="XR.WSA.SurfaceObserver.SurfaceChangedDelegate.html">SurfaceChangedDelegate</a></td><td class="desc"></td><td class="desc1">The SurfaceChanged delegate handles SurfaceChanged events as generated by calling Update on a SurfaceObserver.  Applications can use the bounds, changeType, and updateTime to selectively generate mesh data for the set of known surfaces.</td></tr>
      <tr><td class="descn"></td><td class="lbl"><a href="XR.WSA.SurfaceObserver.SurfaceDataReadyDelegate.html">SurfaceDataReadyDelegate</a></td><td class="desc"></td><td class="desc1">The SurfaceDataReadyDelegate handles events generated when the engine has completed generating a mesh.  Mesh generation is requested through GetMeshAsync and may take many frames to complete.</td></tr>
    </table></div></div></div></div></body></html>