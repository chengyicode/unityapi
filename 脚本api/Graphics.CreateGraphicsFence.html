<!DOCTYPE html> <html> <head> <meta charset="utf-8"> <link href="./css/stylesheet.css" rel="stylesheet" type="text/css"><title>Unity - Scripting API: Graphics.CreateGraphicsFence(GraphicsFenceType,SynchronisationStage)</title></head> <body> <div class="content"><div class="section"><div class="mb20 clear" id=""><h1 class="heading inherit"><a href="Graphics.html">Graphics</a>.CreateGraphicsFence(GraphicsFenceType,SynchronisationStage)</h1><div class="clear"></div><div class="clear"></div><div class="suggest"><div class="suggest-wrap rel hide"><div class="loading hide"><div></div><div></div><div></div></div></div></div><a href="" class="switch-link gray-btn sbtn left hide"></a><div class="clear"></div></div><div class="subsection"><div class="signature"><div class="signature-CS sig-block"><span style="color:red;"></span></div></div></div><div class="subsection"><h2>Parameters</h2><table class="list"><tr><td class="name lbl">fenceType</td><td class="desc"></td><td class="desc1">The type of GraphicsFence to create. Currently the only supported value is GraphicsFenceType.AsyncQueueSynchronization.</td></tr><tr><td class="name lbl">stage</td><td class="desc"></td><td class="desc1">On some platforms there is a significant gap between the vertex processing completing and the pixel processing begining for a given draw call. This parameter allows for the fence to be passed after either the vertex or pixel processing for the proceeding draw has completed. If a compute shader dispatch was the last task submitted then this parameter is ignored.</td></tr></table></div><div class="subsection"><h2>Returns</h2><p><strong>void</strong>
        Returns a new <a href="Rendering.GraphicsFence.html">GraphicsFence</a>.
      </p></div><div class="subsection"><h2>Description   描述</h2><p>Creates a <a href="Rendering.GraphicsFence.html">GraphicsFence</a> which will be passed after the last Blit, Clear, Draw, Dispatch or Texture Copy command prior to this call has been completed on the GPU.</p></div><div class="subsection"><p>This includes those from <a href="Rendering.CommandBuffer.html">CommandBuffer</a>'s that have been executed immediately prior to the creation of the fence.<br /><br />Some platforms cannot differentiate between the completion of vertex and pixel processing, on these platforms the fence is passed after the pixel processing has completed regardless of the value passed to the stage parameter.<br /><br />This function can still be called on platforms that do not support GPUFences though the resulting fence will have no function and will do nothing if waited on (see <a href="Graphics.WaitOnAsyncGraphicsFence.html">Graphics.WaitOnAsyncGraphicsFence</a> and <a href="Rendering.CommandBuffer.WaitOnAsyncGraphicsFence.html">CommandBuffer.WaitOnAsyncGraphicsFence</a>).<br /><br />See Also:<a href="Rendering.GraphicsFence.html">GraphicsFence</a>, <a href="Graphics.WaitOnAsyncGraphicsFence.html">Graphics.WaitOnAsyncGraphicsFence</a>, <a href="Rendering.CommandBuffer.WaitOnAsyncGraphicsFence.html">CommandBuffer.WaitOnAsyncGraphicsFence</a>, <a href="SystemInfo-supportsGraphicsFence.html">SystemInfo.supportsGraphicsFence</a>.</p></div></div></div></div></body></html>